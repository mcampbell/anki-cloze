#!/usr/bin/env ruby
# frozen_string_literal: true

require 'slop'
require 'set'

# Represents a generator for Anki cloze deletions.
class AnkiClozeGenerator
  def initialize(words, min_chunk_size: 1)
    @words = words.flat_map { |a| a.to_s.strip.split(/\s+/) }.reject(&:empty?)
    @min_chunk_size = min_chunk_size
  end

  def generate
    return if @words.empty?

    max_chunk_size = (@words.size / 2.0).ceil
    max_chunk_size = 1 if max_chunk_size < 1

    (1..max_chunk_size).each do |chunk_size|
      lines = emit_clozes_for_chunk_size(chunk_size)
      lines.each { |line| puts line } unless lines.nil?
    end
  end

  private

  def cloze(clause, n)
    return '' if n.nil? || clause.nil? || !n.positive?
    "{{c#{n}::#{clause}}}"
  end

  def emit_clozes_for_chunk_size(chunks)
    return if chunks < @min_chunk_size

    (1..chunks).map do |pass|
      acc = []
      offset = pass - 1

      if offset > 0
        prefix = @words[0...offset].flatten.join(' ')
        acc << if prefix.strip.split(/\s+/).length < chunks
                 prefix
               else
                 cloze(prefix, 1)
               end
      end

      remainder = @words[offset..] || []
      slices = remainder.each_slice(chunks).map.with_index do |slice, idx|
        if slice.length < chunks
          slice.join(' ')
        else
          cloze(slice.join(' '), idx + 1)
        end
      end

      acc.concat(slices).join(' ')
    end
  end
end

if __FILE__ == $0
  begin
    opts = Slop.parse(ARGV) do |o|
      o.banner = 'Usage: anki-cloze [--chunks N] text...'
      o.integer '-m', '--minimum-chunk-size', 'The minimum chunk size to emit (default: 1)', default: 1
      o.on '-h', '--help', 'print help' do
        puts o
        exit
      end
    end

    generator = AnkiClozeGenerator.new(opts.arguments, min_chunk_size: opts[:minimum_chunk_size])
    generator.generate
  rescue Slop::Error => e
    warn e.message
    exit 2
  end
end
