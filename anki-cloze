#!/usr/bin/env ruby
# frozen_string_literal: true

require 'slop'
require 'set'

# Make cloze available for unit tests by defining it before running CLI code.
def cloze(clause, n)
  if n.nil? || clause.nil? || n < 1
    ''
  else
    "{{c#{n}::#{clause}}}"
  end
end

def emit_clozes(chunks, words)
  (1..chunks).each do |pass|
    acc = []
    offset = (pass - 1)
    index_delta = offset == 0 ? 0 : 1

    # first words we don't use on this pass
    if offset > 0
      prefix = words[0...offset].flatten.join(' ')
      # If the prefix is smaller than the requested chunk size, leave it plain
      if prefix.strip.split(/\s+/).length < chunks
        acc << prefix
      else
        acc << cloze(prefix, 1)
      end
    end

    remainder = words[offset..] || []
    slices = remainder.each_slice(chunks).map.each_with_index do |slice, idx|
      if slice.length < chunks
        slice.join(' ')
      else
        cloze(slice.join(' '), idx + 1)
      end
    end

    acc << slices
    puts acc.join(' ')
  end
end

if __FILE__ == $0
  begin
    opts = Slop.parse(ARGV) do |o|
      o.banner = 'Usage: anki-cloze [--chunks N] text...'
    end
  rescue Slop::Error => e
    warn e.message
    exit 2
  end

  # Remaining non-option arguments
  words = opts.arguments.flat_map { |a| a.to_s.strip.split(/\s+/) }.reject(&:empty?)

  if words.empty?
    puts ''
    exit 0
  end

  # For a chunk size of N we need N passes to generate all the outputs.

  # Logic: Start at the beginning + pass'th word, and collect as many words
  # as the chunk size into a group.  Join the group by a space and cloze it.

  # Call emit_clozes for chunk sizes from 1 up to n, where n is half the number
  # of words (rounded up). For example: 10 -> 5, 9 -> 5. Ensure at least 1.
  n = (words.size / 2.0).ceil
  n = 1 if n < 1
  (1..n).each do |chunk_size|
    emit_clozes(chunk_size, words)
  end

end